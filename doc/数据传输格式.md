# 数据传输格式

# 设计思路

### 方案 A：前端直接生成 protobuf binary

- 使用 `protobuf.js` 或官方 protobuf 库
- 定义和后端同样的 proto 文件
- 前端直接用 `Message.encode(msg).finish()` 生成二进制发送

### 方案 B：前端发送 JSON

- 直接发送 JSON（TextMessage）
- 服务器接收到 JSON 后 **再转成 protobuf struct**
- 好处：前端简单，不用 protobuf 编码
- 坏处：消息体大一点，解析略慢

### 当前方案：

#### 1. 前端 / 客户端流程

1. **构造消息**

   - 使用 JSON（可读、方便调试）构造消息数据。
   - 例如：

   ```
   {
       "avatar": "1",
       "fromUserName": "2",
       "from": "6",
       "to": "5",
       "content": "hello world",
       ...
   }
   ```

2. **JSON → Go struct（v1.Message）**

   - `json.Unmarshal` 把 JSON 转成 Go 的 protobuf 结构体对象。

3. **Go struct → Protobuf 二进制**

   - `proto.Marshal(&msg)` 将结构体编码成 protobuf binary 数据（[]byte）。
   - 这个二进制数据比 JSON 小、解析快，符合后端 proto 消息规范。

4. **通过 WebSocket 发送 binary 消息**

   - `conn.WriteMessage(websocket.BinaryMessage, data)`
   - 服务器端直接读取 binary 消息进行 protobuf 解码。

------

#### 2. 后端 / 服务器流程

1. **接收 WebSocket 消息**

   - 从连接读取数据帧：

     ```
     _, msg, err := conn.ReadMessage()
     ```

2. **解码 protobuf binary**

   - 使用 `proto.Unmarshal(msg, &v1.Message{})` 将二进制数据还原成结构体对象。

3. **处理业务逻辑**

   - 例如广播给其他客户端、存入数据库、处理文件或图片等。

4. **返回/广播**

   - 可以继续通过 WebSocket 发送 protobuf binary 消息给其他客户端。